<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Debug Callback  - OpenTK</title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Debug Callback ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  
  

    <meta name="author" content="The Open Toolkit Project">
    <meta property="og:image" content="https://opentk.net/otkBig.png">
    <meta property="og:image:width" content="142">
    <meta property="og:image:height" content="50">
    <meta property="og:site_name" content="OpenTK">
    <meta property="og:title" content="Debug Callback  - OpenTK">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation" style="background: #0052cc;">
          <div class="container">
            <a class="navbar-brand" href="../../index.html">
          <img id="logo" src="../../otkBig.png" alt="">
        </a>
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="debug-callback">Debug Callback</h1>

<p>OpenGL didn't have a comprehensive error notification system at its inception.
The programmer was limited to querying <code>glError()</code> after commands, and the
information provided in the return value was nothing more than the code for the
error. However since then, OpenGL has introduced the ability for programmers to
register a callback function which delivers crucial debugging messages like
errors and warnings to your code.</p>
<p>The history of the debug callback dates to OpenGL 3.0, where AMD created the
vendor specific extension <a href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_debug_output.txt" title="Specification document for AMD_debug_output."><code>AMD_debug_output</code></a> providing this functionality.
This extensions was later approved by the OpenGL Architecture Review Board (ARB)
as the extension <a href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_debug_output.txt" title="Specification document for ARB_debug_output."><code>ARB_debug_output</code></a> in 2010. Finally, since OpenGL
4.3, the extension is a core part of the API, as well as the extension
<a href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt" title="Specification document for KHR_debug."><code>KHR_debug</code></a>. This article covers usage of
both <code>ARB_debug_output</code> extension and the 4.3+ API. <code>KHR_debug</code> however covers
so much more than what was introduced in the original extension.</p>
<p>First and foremost, you should create your OpenGL context with the Debug flag
set. Without the debug flag OpenGL will not generate debugging messages nor
send them to your callback function.</p>
<div class="tabGroup" id="tabgroup_bHGHmlrG6S">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S_debug-context-3" role="tab" aria-controls="tabpanel_bHGHmlrG6S_debug-context-3" data-tab="debug-context-3" tabindex="0" aria-selected="true">OpenTK 3.0</a>
</li>
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S_debug-context-4" role="tab" aria-controls="tabpanel_bHGHmlrG6S_debug-context-4" data-tab="debug-context-4" tabindex="-1">OpenTK 4.0</a>
</li>
</ul>
<section id="tabpanel_bHGHmlrG6S_debug-context-3" role="tabpanel" data-tab="debug-context-3">

<pre><code class="lang-cs">using OpenTK;
using OpenTK.Graphics;

// ...

GameWindow window = new GameWindow(
    width, height,                  // Window width.
    GraphicsMode.Default,           // Context graphics mode.
    title,                          // Window title.
    GameWindowFlags.Default,        // GameWindow flags.
    DisplayDevice.Default,          // The display to create the window in.
    3, 3,                           // OpenGL context version major then minor.
    GraphicsContextFlags.Debug);    // OpenGL context flags.
</code></pre>
</section>
<section id="tabpanel_bHGHmlrG6S_debug-context-4" role="tabpanel" data-tab="debug-context-4" aria-hidden="true" hidden="hidden">

<pre><code class="lang-cs">using OpenTK;
using OpenTK.Windowing.Desktop;

// ...

GameWindow window = new GameWindow(
    GameWindowSettings.Default,
    new NativeWindowSettings() {
        Flags = ContextFlags.Debug
    });
</code></pre>
</section>
</div>
<br>
<p>Then you should create a function which will execute when OpenGL has
debugging information to relay to your program.</p>
<pre><code class="lang-cs">using System;
using System.Runtime.InteropServices;
using OpenTK.Graphics.OpenGL4; // Or alternatively OpenTK.Graphics.OpenGL

// ...

private static void OnDebugMessage(
    DebugSource source,     // Source of the debugging message.
    DebugType type,         // Type of the debugging message.
    int id,                 // ID associated with the message.
    DebugSeverity severity, // Severity of the message.
    int length,             // Length of the string in pMessage.
    IntPtr pMessage,        // Pointer to message string.
    IntPtr pUserParam)      // The pointer you gave to OpenGL, explained later.
{
    // In order to access the string pointed to by pMessage, you can use Marshal
    // class to copy its contents to a C# string without unsafe code. You can
    // also use the new function Marshal.PtrToStringUTF8 since .NET Core 1.1.
    string message = Marshal.PtrToStringAnsi(pMessage, length);

    // The rest of the function is up to you to implement, however a debug output
    // is always useful.
    Console.WriteLine(&quot;[{0} source={1} type={2} id={3}] {4}&quot;, severity, source, type, id, message);

    // Potentially, you may want to throw from the function for certain severity
    // messages.
    if (type == DebugType.DebugTypeError)
    {
        throw new Exception(message);
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Neither the access modifier or whether the method is an instance method or a
static method matters.</p>
</div>
<div class="WARNING">
<h5>Warning</h5>
<p>This function is called from native code, which means there are stack frames
associated with them. If your debugger does not support mixed-mode debugging
it may affect your user experience if an exception is thrown or occurs within
the callback.</p>
</div>
<p>Then you should create a delegate which encapsulates the function you just
implmented.</p>
<div class="tabGroup" id="tabgroup_bHGHmlrG6S-1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S-1_delegate-gl" role="tab" aria-controls="tabpanel_bHGHmlrG6S-1_delegate-gl" data-tab="delegate-gl" tabindex="0" aria-selected="true">Base</a>
</li>
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S-1_delegate-khr" role="tab" aria-controls="tabpanel_bHGHmlrG6S-1_delegate-khr" data-tab="delegate-khr" tabindex="-1">KHR_debug</a>
</li>
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S-1_delegate-arb" role="tab" aria-controls="tabpanel_bHGHmlrG6S-1_delegate-arb" data-tab="delegate-arb" tabindex="-1">ARB_debug_output</a>
</li>
</ul>
<section id="tabpanel_bHGHmlrG6S-1_delegate-gl" role="tabpanel" data-tab="delegate-gl">

<pre><code class="lang-cs">private static GLDebugProc DebugMessageDelegate = OnDebugMessage;
</code></pre>
</section>
<section id="tabpanel_bHGHmlrG6S-1_delegate-khr" role="tabpanel" data-tab="delegate-khr" aria-hidden="true" hidden="hidden">

<pre><code class="lang-cs">private static GLDebugProcKHR DebugMessageDelegate = OnDebugMessage;
</code></pre>
</section>
<section id="tabpanel_bHGHmlrG6S-1_delegate-arb" role="tabpanel" data-tab="delegate-arb" aria-hidden="true" hidden="hidden">

<pre><code class="lang-cs">private static GLDebugProcARB DebugMessageDelegate = OnDebugMessage;
</code></pre>
</section>
</div>
<br>
<div class="NOTE">
<h5>Note</h5>
<p>Creating this reference is critical. A delegate is managed by the .NET garbage
collector, however, this delegate will be passed to a native function as a
pointer. The garbage collector cannot track outside references, and if there
are no references to the delegate, the pointer passed to the native function
becomes &quot;dangling&quot; (in simpler terms, invalid). This causes an access violation
whenever OpenGL attempts to call you back.</p>
<p>And as before, access modifiers and instance/static do not matter as long as it
suits your code.</p>
</div>
<p>Finally you can provide OpenGL your delegate as your debug callback. You can now
enable debug output, and optionally enable synchronous output.</p>
<div class="tabGroup" id="tabgroup_bHGHmlrG6S-2">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S-2_enable-gl" role="tab" aria-controls="tabpanel_bHGHmlrG6S-2_enable-gl" data-tab="enable-gl" tabindex="0" aria-selected="true">Base</a>
</li>
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S-2_enable-khr" role="tab" aria-controls="tabpanel_bHGHmlrG6S-2_enable-khr" data-tab="enable-khr" tabindex="-1">KHR_debug</a>
</li>
<li role="presentation">
<a href="#tabpanel_bHGHmlrG6S-2_enable-arb" role="tab" aria-controls="tabpanel_bHGHmlrG6S-2_enable-arb" data-tab="enable-arb" tabindex="-1">ARB_debug_output</a>
</li>
</ul>
<section id="tabpanel_bHGHmlrG6S-2_enable-gl" role="tabpanel" data-tab="enable-gl">

<pre><code class="lang-cs">GL.DebugMessageCallback(DebugMessageDelegate, IntPtr.Zero);
GL.Enable(EnableCap.DebugOutput);

// Optionally
GL.Enable(EnableCap.DebugOutputSynchronous)
</code></pre>
</section>
<section id="tabpanel_bHGHmlrG6S-2_enable-khr" role="tabpanel" data-tab="enable-khr" aria-hidden="true" hidden="hidden">

<pre><code class="lang-cs">GL.Khr.DebugMessageCallback(DebugMessageDelegate, IntPtr.Zero);
GL.Enable(EnableCap.DebugOutput);

// Optionally
GL.Enable(EnableCap.DebugOutputSynchronous)
</code></pre>
</section>
<section id="tabpanel_bHGHmlrG6S-2_enable-arb" role="tabpanel" data-tab="enable-arb" aria-hidden="true" hidden="hidden">

<pre><code class="lang-cs">GL.Arb.DebugMessageCallback(DebugMessageDelegate, IntPtr.Zero);
GL.Enable(EnableCap.DebugOutput);

// Optionally
GL.Enable(EnableCap.DebugOutputSynchronous)
</code></pre>
</section>
</div>
<br>
<div class="TIP">
<h5>Tip</h5>
<p>Using synchronous output may decrease your performance significantly as OpenGL
cannot defer command execution to other threads and forces validation of
parameters immediately. However, this will allow you to easily break in the
callback function to analyze the situtaion, such as viewing the stack trace
and finding the culprit code. Otherwise the graphics driver is allowed to
call the function from any thread concurrently. Be careful of the usual
pitfalls of multithreading when disabled.</p>
</div>
<div class="NOTE">
<h5>Note</h5>
<p>The second paramter of <code>DebugMessageCallback*</code> determines the value of the
<code>pUserParam</code> parameter in the callback. This parameter is designed for C users
which has no concept delegates, but only function pointers. If you are very
interested in using this parameter (instead of capturing objects via the
delegate as recommended) you can use any C# pointer, or a pointer to a C#
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.gchandle?view=net-7.0" title="A structure which allows native code to reference a C# object.">GCHandle</a>.
Common pointer gotchas apply.</p>
</div>
<h2 id="references">References</h2>
<ul>
<li>This page is based on the <a href="https://gist.github.com/Vassalware/d47ff5e60580caf2cbbf0f31aa20af5d" title="The original page this documentation is based on.">gist of Vassalware</a> on the topic.</li>
<li><a href="https://registry.khronos.org/OpenGL/extensions/AMD/AMD_debug_output.txt" title="Specification document for AMD_debug_output.">AMD_debug_output</a></li>
<li><a href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_debug_output.txt" title="Specification document for ARB_debug_output.">ARB_debug_output</a></li>
<li><a href="https://registry.khronos.org/OpenGL/extensions/KHR/KHR_debug.txt" title="Specification document for KHR_debug.">KHR_debug</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal?view=net-6.0" title="Reference page for System.Runtime.InteropServices.Marshal class.">System.Runtime.InteropServices.Marshal</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.gchandle?view=net-7.0" title="A structure which allows native code to reference a C# object.">System.Runtime.InteropServices.GCHandle</a></li>
</ul>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
